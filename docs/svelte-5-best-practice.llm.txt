# Svelte 5 Best Practices - Modal Component Conversion

## Overview
This document captures the key learnings and best practices from converting the Modal component from Svelte 4 to Svelte 5. These patterns apply to all Svelte 5 component development.

## Core Svelte 5 Patterns

### 1. Use $props() instead of export let

**❌ Svelte 4 Pattern:**
```typescript
export let content: any = null;
export let isOpen: boolean = false;
export let dark: boolean = false;
export let buttons: Array<{...}> = [];
```

**✅ Svelte 5 Best Practice:**
```typescript
let {
  children,
  isOpen = false,
  dark = false,
  buttons = []
}: {
  children?: any;
  isOpen?: boolean;
  dark?: boolean;
  buttons?: Array<{ text: string; callback: () => void; primary?: boolean; disabled?: boolean }>;
} = $props();
```

**Why this is better:**
- Full TypeScript integration
- Explicit type definitions
- Better IDE support and autocomplete
- Compile-time type checking

### 2. Use $state() for reactive variables

**❌ Svelte 4 Pattern:**
```typescript
let animationStage: 'closed' | 'opening' | 'settling' | 'open' = 'closed';
```

**✅ Svelte 5 Best Practice:**
```typescript
let animationStage = $state<'closed' | 'opening' | 'settling' | 'open'>('closed');
```

**Why this is better:**
- Fine-grained reactivity
- Only triggers updates when actually needed
- Better performance than $: reactive statements
- Clearer intent that variable is reactive

### 3. Use $effect() instead of $: reactive statements

**❌ Svelte 4 Pattern:**
```typescript
$: if (isOpen && animationStage === 'closed') {
    animationStage = 'opening';
    setTimeout(() => {
        animationStage = 'settling';
    }, 200);
    setTimeout(() => {
        animationStage = 'open';
    }, 400);
} else if (!isOpen) {
    animationStage = 'closed';
}
```

**✅ Svelte 5 Best Practice:**
```typescript
$effect(() => {
    if (isOpen && animationStage === 'closed') {
        animationStage = 'opening';
        setTimeout(() => {
            animationStage = 'settling';
        }, 200);
        setTimeout(() => {
            animationStage = 'open';
        }, 400);
    } else if (!isOpen) {
        animationStage = 'closed';
    }
});
```

**Why this is better:**
- Automatic dependency tracking
- More efficient re-runs
- Better debugging capabilities
- Consistent with other runes

### 4. Use Snippet System for Content Passing

**❌ Svelte 4 Pattern:**
```typescript
// Function-based content passing (doesn't work in Svelte 5)
content={() => (
    <h2>Title</h2>
    <p>Description</p>
)}
```

**✅ Svelte 5 Best Practice:**
```svelte
<!-- Define snippets at component level -->
{#snippet content()}
    <h2>Title</h2>
    <p>Description</p>
{/snippet}

<!-- Use snippets in components -->
<Modal>
    {@render content()}
</Modal>
```

**Why this is better:**
- Proper Svelte template syntax
- TypeScript recognizes snippet structure
- Better performance (no function overhead)
- Cleaner component interfaces

## Component Architecture Best Practices

### 1. Props Interface Design

```typescript
// Clear, typed props with defaults
let {
  children,
  isOpen = false,
  dark = false,
  buttons = []
}: {
  children?: any;                    // Optional content
  isOpen?: boolean;                  // Optional state
  dark?: boolean;                    // Optional styling
  buttons?: Array<{                  // Optional array with typed items
    text: string;
    callback: () => void;
    primary?: boolean;
    disabled?: boolean;
  }>;
} = $props();
```

### 2. Reactive State Management

```typescript
// Use $state for all UI-updating variables
let animationStage = $state<'closed' | 'opening' | 'settling' | 'open'>('closed');

// Use $effect for side effects and complex logic
$effect(() => {
    // Automatically tracks dependencies: isOpen, animationStage
    if (isOpen && animationStage === 'closed') {
        // Animation logic
    }
});
```

### 3. Event Handling Patterns

```typescript
// Clean event handlers that work with reactive state
function handleBackdropClick() {
    isOpen = false;  // Direct mutation works with $state
}

function handleBackdropKeydown(event: KeyboardEvent) {
    if (event.key === 'Escape') {
        isOpen = false;
    }
}
```

## Migration Strategy

### Step 1: Update Props System
1. Replace all `export let` with `$props()`
2. Add proper TypeScript interfaces
3. Set sensible defaults

### Step 2: Convert Reactive Variables
1. Replace `let` with `$state()` for reactive variables
2. Update `$:` statements to `$effect()`
3. Test reactivity still works

### Step 3: Fix Content Passing
1. Replace function-based content props with snippets
2. Define snippets at component level
3. Update all component usages

### Step 4: TypeScript Integration
1. Ensure all props are properly typed
2. Fix any interface mismatches
3. Verify compilation succeeds

## Common Pitfalls to Avoid

### 1. JSX Syntax in Functions
```typescript
// ❌ This doesn't work in Svelte 5
content={() => (
    <div>
        <h2>Title</h2>
        <p>Description</p>
    </div>
)}

// ✅ Use snippets instead
{#snippet content()}
    <div>
        <h2>Title</h2>
        <p>Description</p>
    </div>
{/snippet}
```

### 2. Inline Snippet Definitions
```svelte
<!-- ❌ TypeScript doesn't recognize this -->
<Modal>
    {#snippet content()}
        <h2>Title</h2>
    {/snippet}
    {@render content()}
</Modal>

<!-- ✅ Define snippets at component level -->
{#snippet modalContent()}
    <h2>Title</h2>
{/snippet}

<Modal>
    {@render modalContent()}
</Modal>
```

### 3. Mixing Svelte 4 and 5 Patterns
```typescript
// ❌ Don't mix patterns
export let isOpen = false;  // Svelte 4
let stage = $state('closed');  // Svelte 5

// ✅ Be consistent
let {
  isOpen = false
}: { isOpen?: boolean } = $props();  // Svelte 5
let stage = $state('closed');        // Svelte 5
```

## Performance Benefits

### 1. Fine-Grained Reactivity
- `$state()` only updates components that actually use the data
- `$effect()` runs only when dependencies change
- Better than Svelte 4's coarse-grained reactivity

### 2. Reduced Overhead
- No more complex `$:` statement evaluation
- Direct state mutations are faster
- Snippet rendering is more efficient than function calls

### 3. Better Tree Shaking
- Unused runes are eliminated in build
- Smaller bundle sizes
- Faster initialization

## Testing Strategy

### 1. Unit Testing
```typescript
// Test reactive behavior
test('animation stage updates on open', () => {
    const { getByTestId } = render(Modal, { isOpen: true });
    expect(getByTestId('modal')).toHaveClass('opening');
});
```

### 2. Integration Testing
```typescript
// Test snippet rendering
test('snippet content renders correctly', () => {
    const { getByText } = render(Modal, {
        children: () => 'Test Content'
    });
    expect(getByText('Test Content')).toBeInTheDocument();
});
```

### 3. Type Testing
```typescript
// TypeScript should catch these at compile time
// Invalid props should cause compilation errors
```

## Conclusion

The Modal component conversion demonstrates that Svelte 5 provides:
- **Better Performance**: Through fine-grained reactivity
- **Improved Type Safety**: With proper TypeScript integration
- **Cleaner Syntax**: Using modern runes and snippets
- **Future-Proof Code**: Following latest Svelte patterns

These patterns should be applied to all component development in Svelte 5 projects.

## Files Successfully Converted
- `/src/lib/components/Modal/Modal.svelte` - Main component
- `/src/lib/components/Explorer/Explorer.svelte` - Usage pattern
- `/src/lib/components/VList/VList.svelte` - Usage pattern  
- `/src/routes/practice/+page.svelte` - Usage pattern
- `/src/routes/examples/modal-examples.svelte` - Usage patterns

All components now follow Svelte 5 best practices with zero compilation errors.
